generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// ENUM DEFINITIONS
// ============================================

enum WatchlistStatus {
  PLAN_TO_WATCH
  WATCHING
  WATCHED

  @@map("watchlist_status")
}

enum WatchlistType {
  ANIME
  MOVIE
  SHOW

  @@map("watchlist_type")
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE

  @@map("task_status")
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH

  @@map("task_priority")
}

enum GamePlaylistStatus {
  PLAYLIST
  PLAYING
  PLAYED

  @@map("game_playlist_status")
}

enum GameScoreStatus {
  scheduled
  live
  final

  @@map("game_score_status")
}

enum SportType {
  NBA
  NFL
  MLB
  NHL
  MLS

  @@map("sport_type")
}

enum TopItemType {
  anime
  movie
  show

  @@map("top_item_type")
}

enum HttpMethod {
  GET
  POST
  PUT
  DELETE
  PATCH

  @@map("http_method")
}

enum ApiErrorType {
  RATE_LIMIT
  TIMEOUT
  SERVER_ERROR
  CLIENT_ERROR
  NETWORK_ERROR

  @@map("api_error_type")
}

enum AggregationType {
  HOURLY
  DAILY
  MONTHLY

  @@map("aggregation_type")
}

enum AlertType {
  RATE_LIMIT_WARNING
  COST_THRESHOLD
  ERROR_SPIKE

  @@map("alert_type")
}

enum AlertPeriod {
  MINUTE
  HOUR
  DAY

  @@map("alert_period")
}

// ============================================
// MODELS
// ============================================

model WatchlistItem {
  id         String          @id(map: "WatchlistItem_pkey") @default(cuid())
  type       WatchlistType
  title      String
  status     WatchlistStatus @default(PLAN_TO_WATCH)
  externalId String          @map("external_id")
  imageUrl   String?         @map("image_url")
  rating     Float?
  year       Int?
  episodes   Int?
  createdAt  DateTime        @default(now()) @map("created_at")
  updatedAt  DateTime        @updatedAt @map("updated_at")

  @@unique([externalId, type])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([type, status], map: "watchlist_items_type_status_idx")
  @@map("watchlist_items")
}

model StockQuote {
  symbol        String   @id(map: "stock_quotes_new_pkey")
  companyName   String?  @map("company_name")
  logoUrl       String?  @map("logo_url")
  currentPrice  Float    @map("current_price")
  change        Float
  percentChange Float    @map("percent_change")
  lastUpdated   DateTime @default(now()) @map("last_updated")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  @@index([lastUpdated])
  @@map("stock_quotes")
}

model DailyQuote {
  date      String   @id(map: "daily_quotes_new_pkey")
  content   String
  author    String
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  @@map("daily_quotes")
}

model CryptoQuote {
  symbol            String   @id(map: "crypto_quotes_new_pkey")
  name              String
  logoUrl           String?  @map("logo_url")
  price             Float
  percentChange24h  Float?   @map("percent_change_24h")
  lastUpdated       DateTime @default(now()) @map("last_updated")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at")
  // Rate limit optimization fields
  cmcId             Int?     @map("cmc_id") // Cache CoinMarketCap ID to skip map API calls
  metadataUpdatedAt DateTime? @map("metadata_updated_at") // Track when logo/name was last fetched

  @@map("crypto_quotes")
}

model TopItem {
  id          String      @id
  type        TopItemType
  title       String
  imageUrl    String      @map("image_url")
  year        Int?
  rating      Float
  episodes    Int?
  externalId  Int         @map("external_id")
  lastUpdated DateTime    @default(now()) @map("last_updated")
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @default(now()) @updatedAt @map("updated_at")

  @@unique([externalId, type])
  @@index([type])
  @@index([lastUpdated])
  @@map("top_items")
}

model ApiUsage {
  id           String        @id @default(cuid())
  apiName      String        @map("api_name")
  endpoint     String?
  method       HttpMethod?   @default(GET)
  timestamp    DateTime      @default(now())

  // Performance metrics
  responseTime Int?          @map("response_time") // milliseconds
  requestSize  Int?          @map("request_size")  // bytes
  responseSize Int?          @map("response_size") // bytes

  // Status tracking
  success      Boolean       @default(true)
  statusCode   Int?          @map("status_code")
  errorType    ApiErrorType? @map("error_type")
  errorMessage String?       @map("error_message") @db.Text

  // Cost tracking
  costCredits  Float?        @map("cost_credits")  // API credit cost

  // Request metadata
  cached       Boolean       @default(false)
  userId       String?       @map("user_id")       // if user-specific

  createdAt    DateTime      @default(now()) @map("created_at")

  // Optimized indexes for common queries
  @@index([apiName, timestamp(sort: Desc)])
  @@index([timestamp(sort: Desc)])
  @@index([apiName, success, timestamp])
  @@index([success, timestamp])
  @@index([apiName, endpoint, timestamp])
  @@map("api_usage")
}

model ApiUsageAggregate {
  id              String          @id @default(cuid())
  apiName         String          @map("api_name")
  endpoint        String?
  aggregationType AggregationType @map("aggregation_type")
  periodStart     DateTime        @map("period_start")
  periodEnd       DateTime        @map("period_end")

  // Counts
  totalRequests   Int             @map("total_requests")
  successCount    Int             @map("success_count")
  errorCount      Int             @map("error_count")
  cachedCount     Int             @map("cached_count")

  // Performance metrics (aggregated)
  avgResponseTime Float?          @map("avg_response_time")
  maxResponseTime Int?            @map("max_response_time")
  minResponseTime Int?            @map("min_response_time")

  // Error breakdown
  rateLimitErrors Int             @default(0) @map("rate_limit_errors")
  timeoutErrors   Int             @default(0) @map("timeout_errors")
  serverErrors    Int             @default(0) @map("server_errors")

  // Cost
  totalCost       Float?          @map("total_cost")

  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  @@unique([apiName, aggregationType, periodStart])
  @@index([periodStart, aggregationType])
  @@map("api_usage_aggregates")
}

model ApiAlert {
  id            String      @id @default(cuid())
  apiName       String      @map("api_name")
  alertType     AlertType   @map("alert_type")
  threshold     Float       // percentage or absolute value
  period        AlertPeriod

  enabled       Boolean     @default(true)
  lastTriggered DateTime?   @map("last_triggered")

  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  @@unique([apiName, alertType, period])
  @@index([apiName, enabled])
  @@map("api_alerts")
}

model GameScore {
  id            String          @id @default(cuid())
  gameId        String          @map("game_id")
  sport         SportType
  date          DateTime        @db.Date
  homeTeam      String          @map("home_team")
  awayTeam      String          @map("away_team")
  homeScore     Int             @map("home_score")
  awayScore     Int             @map("away_score")
  homeTeamLogo  String?         @map("home_team_logo")
  awayTeamLogo  String?         @map("away_team_logo")
  status        GameScoreStatus
  quarter       String?
  timeRemaining String?         @map("time_remaining")
  startTime     DateTime        @map("start_time")
  playoffRound  String?         @map("playoff_round")
  odds          Json?
  topScorer     Json?           @map("top_scorer")
  expiresAt     DateTime?       @map("expires_at")
  lastUpdated   DateTime        @default(now()) @map("last_updated")
  createdAt     DateTime        @default(now()) @map("created_at")
  updatedAt     DateTime        @default(now()) @updatedAt @map("updated_at")

  @@unique([gameId, sport, date])
  @@index([sport, date])
  @@index([sport, status])
  @@index([status, expiresAt])
  @@index([lastUpdated])
  @@map("game_scores")
}

model TopPerformer {
  id          String    @id @default(cuid())
  sport       SportType
  date        DateTime  @db.Date
  name        String
  team        String
  imageUrl    String?   @map("image_url")
  stats       Json
  lastUpdated DateTime  @default(now()) @map("last_updated")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  @@unique([sport, date, name])
  @@index([sport, date])
  @@index([lastUpdated])
  @@index([sport, lastUpdated])
  @@map("top_performers")
}

model Folder {
  id        String   @id @default(cuid())
  name      String
  parentId  String?  @map("parent_id")
  parent    Folder?  @relation("FolderToFolder", fields: [parentId], references: [id], onDelete: SetNull)
  children  Folder[] @relation("FolderToFolder")
  notes     Note[]
  isPinned  Boolean  @default(false) @map("is_pinned")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([parentId])
  @@index([isPinned])
  @@index([createdAt])
  @@map("folders")
}

model Note {
  id          String           @id @default(cuid())
  title       String
  content     String           @db.Text
  folderId    String?          @map("folder_id")
  folder      Folder?          @relation(fields: [folderId], references: [id], onDelete: SetNull)
  isPinned    Boolean          @default(false) @map("is_pinned")
  isDeleted   Boolean          @default(false) @map("is_deleted")
  deletedAt   DateTime?        @map("deleted_at")
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")
  tags        NoteTag[]
  attachments NoteAttachment[]
  taskNotes   TaskNote[]

  @@index([folderId])
  @@index([isPinned])
  @@index([isDeleted])
  @@index([createdAt])
  @@index([updatedAt])
  @@map("notes")
}

model Tag {
  id        String    @id @default(cuid())
  name      String    @unique
  color     String    @default("#6366f1")
  createdAt DateTime  @default(now()) @map("created_at")
  notes     NoteTag[]

  // Note: @unique already creates an index on name, no separate index needed
  @@map("tags")
}

model NoteTag {
  noteId String @map("note_id")
  tagId  String @map("tag_id")
  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade)
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([noteId, tagId])
  @@index([noteId])
  @@index([tagId])
  @@map("note_tags")
}

model NoteAttachment {
  id        String   @id @default(cuid())
  noteId    String   @map("note_id")
  note      Note     @relation(fields: [noteId], references: [id], onDelete: Cascade)
  fileName  String   @map("file_name")
  fileUrl   String   @map("file_url")
  fileType  String   @map("file_type")
  fileSize  Int      @map("file_size")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([noteId])
  @@map("note_attachments")
}

model TaskNote {
  taskId String @map("task_id")
  noteId String @map("note_id")
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade)

  @@id([taskId, noteId])
  @@index([taskId])
  @@index([noteId])
  @@map("task_notes")
}

model Task {
  id          String       @id @default(cuid())
  title       String
  description String?
  status      TaskStatus   @default(TODO)
  priority    TaskPriority @default(MEDIUM)
  dueDate     DateTime?    @map("due_date") @db.Date
  category    String?
  notes       String?
  position    Int          @default(0)
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")
  taskNotes   TaskNote[]

  @@index([status])
  @@index([status, position])
  @@index([category])
  @@index([priority])
  @@index([dueDate])
  @@index([createdAt])
  @@map("tasks")
}

model Game {
  id          String             @id @default(cuid())
  gameTitle   String             @map("game_title")
  rawgRating  Float?             @map("rawg_rating")
  coverArtUrl String?            @map("cover_art_url")
  status      GamePlaylistStatus @default(PLAYLIST)
  rawgGameId  Int                @unique @map("rawg_game_id")
  releaseDate String?            @map("release_date")
  genres      String?
  platforms   String?
  metacritic  Int?
  createdAt   DateTime           @default(now()) @map("created_at")
  updatedAt   DateTime           @updatedAt @map("updated_at")

  // Composite index covers both status-only and status+createdAt queries
  @@index([status, createdAt])
  @@map("games")
}

model GmailToken {
  id           String   @id @default(cuid())
  accessToken  String   @map("access_token") @db.Text
  refreshToken String   @map("refresh_token") @db.Text
  expiresAt    DateTime @map("expires_at")
  email        String   @unique
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Note: @unique already creates an index on email, no separate index needed
  @@map("gmail_tokens")
}

model TikTokVideo {
  id          String    @id @default(cuid())
  videoId     String    @unique @map("video_id")
  url         String
  title       String?
  thumbnail   String?
  authorName  String?   @map("author_name")
  uploadDate  DateTime? @map("upload_date")
  likedAt     DateTime  @map("liked_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  @@index([likedAt])
  @@index([uploadDate])
  @@map("tiktok_videos")
}

model CommodityQuote {
  symbol        String   @id(map: "commodity_quotes_pkey")
  name          String
  price         Float
  unit          String
  dailyChange   Float?   @map("daily_change")
  percentChange Float?   @map("percent_change")
  previousPrice Float?   @map("previous_price")
  lastUpdated   DateTime @default(now()) @map("last_updated")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")

  @@index([lastUpdated])
  @@map("commodity_quotes")
}

model CommodityPriceHistory {
  id         String   @id @default(cuid())
  symbol     String
  price      Float
  recordedAt DateTime @default(now()) @map("recorded_at")

  @@index([symbol, recordedAt])
  @@map("commodity_price_history")
}

model GasPrice {
  stationId   String   @id @map("station_id")
  station     String
  regular     Float
  scrapedAt   DateTime @map("scraped_at")
  lastUpdated DateTime @default(now()) @map("last_updated")
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at")

  @@map("gas_prices")
}

model KomgaSettings {
  id        String   @id @default(cuid())
  userId    String   @unique @map("user_id") // Single user app, but keeps structure flexible
  serverUrl String   @map("server_url")
  email     String
  password  String   @db.Text // Encrypted password
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Note: @unique already creates an index on userId, no separate index needed
  @@map("komga_settings")
}

model BookmarkFolder {
  id        String           @id @default(cuid())
  name      String
  parentId  String?          @map("parent_id")
  parent    BookmarkFolder?  @relation("BookmarkFolderToBookmarkFolder", fields: [parentId], references: [id], onDelete: SetNull)
  children  BookmarkFolder[] @relation("BookmarkFolderToBookmarkFolder")
  bookmarks Bookmark[]
  isPinned  Boolean          @default(false) @map("is_pinned")
  createdAt DateTime         @default(now()) @map("created_at")
  updatedAt DateTime         @updatedAt @map("updated_at")

  @@index([parentId])
  @@index([isPinned])
  @@index([createdAt])
  @@map("bookmark_folders")
}

model Bookmark {
  id          String          @id @default(cuid())
  url         String
  title       String
  description String?         @db.Text
  faviconUrl  String?         @map("favicon_url")
  folderId    String?         @map("folder_id")
  folder      BookmarkFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)
  isPinned    Boolean         @default(false) @map("is_pinned")
  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @updatedAt @map("updated_at")

  @@index([folderId])
  @@index([isPinned])
  @@index([createdAt])
  @@index([url])
  @@map("bookmarks")
}
